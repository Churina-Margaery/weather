# weather
![gif demo](./diagrams/res.gif)

Участники проекта:
- Быкова Кристина Алексеевна, группа 5130904/20101, роль: `Backend разработчик`
- Кудрявцев Александр Кириллович, группа 5130904/20101, роль: `Тестировщик`
- Чубаров Дмитрий Андреевич, группа 5130904/20101, роль: `Backend разработчик`
- Чурина Маргарита Алексеевна, группа 5130904/20101, роль: `Frontend разработчик`

## Определение проблемы
Пользователи сталкиваются с неудобством при поиске комплексной и наглядной информации о погоде. Существующие метеосервисы часто предоставляют данные о погоде в текущий момент, прогнозе и тд. в разрозненном виде, без удобной визуализации, что затрудняет быстрое восприятие и анализ погодных условий.

## Выработĸа требований
### Пользовательские истории:

| Ситуация (Контекст)         | Потребность (Мотивация)       | Ожидаемый результат                | Решение                              |
|-----------------------------|-------------------------------|------------------------------------|--------------------------------------|
| Перед выходом из дома        | Мгновенно узнать, будут ли осадки | Не взять зонт без необходимости    | Карточка с текущим статусом осадков  |
| Планируя поездку на выходные | Сравнить погоду в разных городах | Выбрать оптимальное место для поездки | Быстрый поиск + графики для разных локаций  |
| Готовясь к тренировке на улице | Оценить ветер и температуру   | Подобрать подходящую экипировку     | Детализированные показатели в карточках |

### Нефункциональные требования:

- Поддержка 10к DAU
- Хранение данных ≥5 лет
- Время отклика API <500 мс (+- 300 мс, зависит от скорости OpenWeatherMap API и Visual Crossing)
- Доступность 99.9% (ориентируемся на доступность внешних API)

## Разработĸа архитеĸтуры и детальное проеĸтирование

### 1. Характеристики нагрузки на сервис

| Параметр          | Значение             | Обоснование                                                                 |
|-------------------|----------------------|-----------------------------------------------------------------------------|
| Соотношение R/W   | 99% Read / 1% Write  | Основная нагрузка — запросы данных. Записи происходят только при кэшировании данных из OpenWeatherMap |
| Суточный трафик   | 10к DAU | Предполагаем, что система будет широко использоваться                                       |
| Пиковая нагрузка  | 200 RPM              | Утром/вечером, проверка погоды перед выходом на улицу                                   |
| Объем данных      | 2-5 ГБ/год         | Хранение данных для СПБ с обновлением каждые 15 мин (≈0.5 КБ/запись) |

### 2. Первые две диаграммы из подхода
#### 1. Контекстная диаграмма (C4 Level 1)
![C4 Контекстная диаграмма (C4 Level 1)](./diagrams/c4-1.drawio.png)
#### 2. Контейнерная диаграмма (C4 Level 2)
![C4 Контейнерная диаграмма (C4 Level 2)](./diagrams/c4-2.drawio.png)

### 3. Контраĸты API
Контраĸты API описаны в файле `API-documentation.md`.

#### Ожидаемые нефунĸциональные требования на время отĸлиĸа:
- Время ответа API: ≤800 мс
- Доступность: 99.9%
- Лимит запросов: 200 RPM

### 4. Схема базы данных + почему она выдержит нефунĸциональные требования

```
CREATE TABLE public.weather_records (
id SERIAL PRIMARY KEY,
date date NOT NULL,
temperature double precision NOT NULL,
wind_speed double precision NOT NULL,
visibility double precision NOT NULL,
pressure integer NOT NULL,
humidity integer NOT NULL,
city character varying(50) NOT NULL
);
```

#### Производительность
Первичный ключ id SERIAL PRIMARY KEY автоматически создает индекс B-tree, обеспечивая быстрый доступ к записям  
Для 10 дней данных (240 записей) даже полное сканирование таблицы выполняется за миллисекунды  
Простые запросы по дате (WHERE date = ...) эффективны благодаря малому объему данных  

#### Масштабируемость (рост нагрузки в 10 раз)
При 10-кратном увеличении:  
- Размер таблицы составит ~250KB  
- Даже без дополнительных индексов производительность останется приемлемой

Система может хранить до 2 миллиардов записей — запас огромный  
Возможность быстрого добавления индексов при необходимости

#### Целостность данных
NOT NULL для всех полей гарантирует отсутствие NULL-значений  
PRIMARY KEY предотвращает дублирование записей по id  
Автоматическая валидация типов данных (база сама проверяет, что в графах "температура", "давление" и т.д. — правильные числа)  

#### Доступность (99.9% uptime)
Простая структура — меньше шансов, что что-то сломается  
Нет сложных связей между данными, которые могут вызвать ошибки  
Поддерживает hot-standby репликацию (можно сделать "резервную копию" базы (реплику), которая подхватит работу, если основная база упадет)
    
Эта схема оптимальна для текущих объемов (3-10 дней) и может масштабироваться до 10x нагрузки без изменений. Все критические нефункциональные требования выполняются за счет:
- Минимального объема данных
- Правильно выбранных типов
- Наличия первичного ключа
- Простоты структуры
    
#### Схема БД
![scheme-db](./diagrams/scheme-db.jpg)
    
### 5. Схема масштабирования сервиса при росте нагрузĸи в 10 раз

#### Вертикальное масштабирование (быстрое решение)
![scheme-10](./diagrams/scheme-10.png)

#### Действия:

- Увеличение мощности сервера БД: 2→4 CPU, 4→8GB RAM
- Добавление 2-3 реплик API серверов за балансировщиком
- Настройка кэширования для часто запрашиваемых данных

## Кодирование и отладĸа
### Бэкенд (Python, Flask)
Технологии:  
Использован микрофреймворк Flask для обработки HTTP-запросов и интеграции с внешним API погоды.  
Для работы с данными реализован модуль database.py.  
Роуты описаны в app.py, бизнес-логика (запросы к API погоды) вынесена в weather.py.

### Фронтенд (React, TypeScript)
Технологии:  
Сборка проекта выполнена на Vite, использовался React+TypeScript.  
Состояние приложения управляется через store (Redux), запросы к бэкенду — через axios (`api-actions.ts`).  

Компоненты разбиты по папкам: pages (страницы), components (UI-элементы), utils (вспомогательные функции).
Типизация данных (интерфейсы погоды) вынесена в types/weather.ts.


### Тестирование
#### Юнит-тесты (Vitest, TypeScript):

Написаны для компонентов React и сервисов.  
Конфигурация Vitest интегрирована с TypeScript для строгой типизации.


#### Интеграционные тесты (Java, Selenium, Allure):

Реализованы на Java с использованием Selenium для автоматизации браузера.
Тесты разбиты на: pages (Page Object Model), elements, test (сценарии).
Отчеты генерируются через Allure.


## Unit тестирование
Для всех компонентов интерфейса написаны Unit тесты. Было решено покрыть тестами именно их, так как это самый удобный способ проверить логику всего приложения.
Для них созданы моки, соответствующие созданному API, чтобы не ждать ответ от сторонних API.  
Тесты можно запустить командой `npm run test`.  
Было решено протестировать именно их, так как бэкенд работает только с БД и сторонними API.
## Интеграционное тестирование
Один из сценариев, покрывающих пользовательскую историю - ввод своего города в строку поиска и просмотр погоды. Реализованы тесты и других фукций интерфейса (переход на гитхаб, смена темы и тд.)  
С учетом специфики сайта все интеграционные тесты написаны на моках (с использованием WireMock), проверяется логика поиска на сайте, перехода на гитхаб, а также отображения различных блоков сайта и их значения.
Тесты написаны на Java, использованы паттерны PageObject, PageElement. Также мокирование вынесено в отдельную утилиту.
Для интеграционных тестов также настроен Allure, для всего проекта настроен CI в виде github Actions, в котором прогоняются Unit-тесты и интеграционные.
По результатам этого прогона формируется Allure-отчет, который можно посмотреть (см. в pipeline с названием deployment) 
## Сборĸа
Сборка тестов вынесена в отдельные контейнеры, чтобы они завершались сразу после завершения тестов.
1. Для сборки необходимо клонировать себе репозиторий:
![git clone](./diagrams/git-clone.jpg)
2. В директории репозитория необходимо создать `.env` файл, аналогичный `.env.example`.
3. Далее запускаем сборку командой `docker compose up -d`.
![docker-compose](./diagrams/docker-compose.jpg)
4. Сайтом можно пользоваться на `http://localhost:8125/`,
API доступно по `http://localhost:8125/api`.
5. Для запуска Unit-тестов и интеграционных тестов используются команды  
- Unit-тесты: `docker compose -f docker-compose.unit-test.yml up --build --abort-on-container-exit`  
![docker-compose](./diagrams/unit-tests.jpg)
- Интеграционные тесты: `docker compose -f docker-compose.ui-test.yml up --build --abort-on-container-exit`
![docker-compose](./diagrams/ui-tests.jpg)
